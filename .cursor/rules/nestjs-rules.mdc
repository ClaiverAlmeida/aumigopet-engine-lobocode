
---
description: "Regras especÃ­ficas para desenvolvimento NestJS no projeto Infraseg"
globs: 
  - "src/**/*.ts"
  - "src/**/*.module.ts"
  - "src/**/*.service.ts"
  - "src/**/*.controller.ts"
  - "src/**/*.guard.ts"
  - "src/**/*.filter.ts"
  - "src/**/*.interceptor.ts"
  - "src/**/*.decorator.ts"
alwaysApply: true
---

# ğŸ§± Regras de Desenvolvimento NestJS - Projeto Infraseg

> **ğŸ“˜ Complemento**: Este documento trabalha em conjunto com o `docs/NAMING_CONVENTIONS.md` que contÃ©m os padrÃµes especÃ­ficos de nomenclatura do projeto.

## ğŸ“‹ Arquitetura do Projeto

### ğŸ—ï¸ Estrutura de MÃ³dulos
- Sempre usar **mÃ³dulos separados** para cada funcionalidade
- Seguir estrutura: `src/modules/[nome]/` para mÃ³dulos de negÃ³cio
- Usar `src/shared/` para funcionalidades compartilhadas
- **Um mÃ³dulo por domÃ­nio principal**
- **Um controller por rota principal**

### ğŸ“ OrganizaÃ§Ã£o de Pastas por MÃ³dulo
```
src/modules/[nome]/
â”œâ”€â”€ dto/                 # Data Transfer Objects
â”œâ”€â”€ entities/            # Entidades do banco
â”œâ”€â”€ services/           # LÃ³gica de negÃ³cio
â”‚   â”œâ”€â”€ base/           # ServiÃ§os base (heranÃ§a)
â”‚   â”œâ”€â”€ [tipo]/         # ServiÃ§os especÃ­ficos por tipo
â”‚   â””â”€â”€ [nome]-query.service.ts # ConstruÃ§Ã£o de queries
â”œâ”€â”€ repositories/       # Acesso a dados
â”œâ”€â”€ validators/         # ValidaÃ§Ãµes centralizadas
â”œâ”€â”€ factories/          # CriaÃ§Ã£o de objetos
â”œâ”€â”€ controllers/        # Endpoints REST
â”œâ”€â”€ guards/            # ProteÃ§Ã£o de rotas
â”œâ”€â”€ filters/           # Tratamento de erros
â”œâ”€â”€ models/            # Tipos de dados
â””â”€â”€ [nome].module.ts   # MÃ³dulo principal
```

## ğŸ¯ PrincÃ­pios Fundamentais

### ğŸ“ Diretrizes Gerais TypeScript
- **Sempre declarar tipos** para variÃ¡veis e funÃ§Ãµes (parÃ¢metros e retorno)
- **Evitar `any`** - criar tipos necessÃ¡rios
- **Usar JSDoc** para documentar classes e mÃ©todos pÃºblicos
- **NÃ£o deixar linhas em branco** dentro de funÃ§Ãµes
- **Um export por arquivo**
- **Seguir princÃ­pios SOLID**

### ğŸ”¤ ConvenÃ§Ãµes de Nomenclatura
- **PascalCase** para classes (`UserService`, `AuthController`)
- **camelCase** para variÃ¡veis, funÃ§Ãµes e mÃ©todos (`userName`, `buscarUserPorId`)
- **kebab-case** para arquivos e diretÃ³rios (`user-service.ts`, `auth-module/`)
- **UPPERCASE** para variÃ¡veis de ambiente (`DATABASE_URL`, `JWT_SECRET`)

#### ğŸ¯ Regras EspecÃ­ficas do Projeto
- **Entidades SEMPRE em inglÃªs**: `User`, `Company`, `Post`, `Role`, `Shift`, `Patrol`, `EventLog`, `PanicEvent`
- **MÃ©todos SEMPRE em portuguÃªs literal**: `buscarUserPorId()`, `validarSeUserExiste()`, `criarNovoAdmin()`
- **Propriedades SEMPRE em inglÃªs**: `id`, `name`, `email`, `companyId`, `postId`, `role`, `active`, `deletedAt`
- **Endpoints SEMPRE em portuguÃªs**: `obterTodosOsUsers()`, `criarNovoAdmin()`, `updateDadosDoUser()`

#### ğŸ” PadrÃµes de Nomenclatura por Categoria

**Busca e Consulta:**
- `buscar[Entity]Por[Criteria]` â†’ `buscarUserPorId()`, `buscarUserPorEmail()`
- `buscarTodos[Entity]` â†’ `buscarTodosOsUsers()`
- `buscar[Entity]sAtivos` â†’ `buscarUsersAtivos()`

**ValidaÃ§Ã£o:**
- `validarSe[Entity]Existe` â†’ `validarSeUserExiste()`
- `validarSe[Field]EhUnico` â†’ `validarSeEmailEhUnico()`
- `validarPermissaoPara[Action]` â†’ `validarPermissaoParaRead()`
- `validarSePode[Action]` â†’ `validarSePodeExecutarAction()`

**CriaÃ§Ã£o:**
- `criarNovo[Entity]` â†’ `criarNovoUser()`, `criarNovoAdmin()`

**AtualizaÃ§Ã£o:**
- `update[Entity]` â†’ `updateUser()`, `updateCompany()`
- `update[Entity][Field]` â†’ `updateUserStatus()`

**ConstruÃ§Ã£o de Queries:**
- `construir[What]Para[Action]` â†’ `construirWhereClauseParaRead()`

**PreparaÃ§Ã£o de Dados:**
- `preparar[What]Para[Action]` â†’ `prepararDadosParaUpdate()`

- **ComeÃ§ar funÃ§Ãµes com verbos** (`buscarUser`, `validarEmail`, `criarNovo`)
- **Usar verbos para variÃ¡veis boolean** (`isLoading`, `hasError`, `canDelete`)
- **Usar palavras completas** ao invÃ©s de abreviaÃ§Ãµes
- **Evitar nÃºmeros mÃ¡gicos** - definir constantes

### ğŸ“Š Exemplos de Nomenclatura
```typescript
// âœ… Correto - Seguindo padrÃµes do projeto
export class UserService {
  private readonly isActiveUser: boolean;
  
  async buscarUserPorId(id: string): Promise<User> {
    // implementaÃ§Ã£o
  }
  
  async validarSeUserExiste(id: string): Promise<boolean> {
    // implementaÃ§Ã£o
  }
  
  async criarNovoAdmin(dto: CreateAdminDto): Promise<User> {
    // implementaÃ§Ã£o
  }
  
  async validarSeEmailEhUnico(email: string, excludeUserId?: string): Promise<boolean> {
    // implementaÃ§Ã£o
  }
}

// âŒ Evitar - NÃ£o segue padrÃµes do projeto
export class UserService {
  private readonly active: any;
  
  async findUserById(id: string): Promise<any> {
    // implementaÃ§Ã£o
  }
  
  async createUser(data: any): Promise<any> {
    // implementaÃ§Ã£o
  }
}
```

## ğŸ”§ ConvenÃ§Ãµes de CÃ³digo

### ğŸ¯ FunÃ§Ãµes e MÃ©todos
- **Escrever funÃ§Ãµes curtas** com propÃ³sito Ãºnico (menos de 20 instruÃ§Ãµes)
- **Nomear funÃ§Ãµes com verbo** e complemento
- **Se retorna boolean**, usar `isX`, `hasX`, `canX`
- **Se nÃ£o retorna nada**, usar `executeX`, `saveX`, `processX`
- **Evitar nesting** usando early returns
- **Usar higher-order functions** (map, filter, reduce)
- **Usar arrow functions** para funÃ§Ãµes simples (menos de 3 instruÃ§Ãµes)
- **Usar parÃ¢metros padrÃ£o** ao invÃ©s de verificar null/undefined
- **Usar RO-RO pattern** para mÃºltiplos parÃ¢metros

### ğŸ“‹ Exemplo de Boas PrÃ¡ticas em FunÃ§Ãµes
```typescript
// âœ… Correto - FunÃ§Ã£o curta com propÃ³sito Ãºnico
async validarPermissaoDoUser(userId: string, permission: string): Promise<boolean> {
  if (!userId || !permission) return false;
  
  const user = await this.userRepository.buscarPorId(userId);
  if (!user) return false;
  
  return user.hasPermission(permission);
}

// âœ… Correto - RO-RO pattern
async criarNovoUser(params: {
  userData: CreateUserDto;
  companyId: string;
  createdBy: string;
}): Promise<{ user: User; success: boolean }> {
  // implementaÃ§Ã£o
}

// âŒ Evitar - FunÃ§Ã£o muito longa e com mÃºltiplas responsabilidades
async processarDadosDoUser(userId: string, action: string, data: any): Promise<any> {
  // 50+ linhas de cÃ³digo misturando validaÃ§Ã£o, processamento e persistÃªncia
}
```

### ğŸ—ï¸ Classes e Estruturas
- **Seguir princÃ­pios SOLID**
- **Preferir composiÃ§Ã£o** sobre heranÃ§a
- **Escrever classes pequenas** (menos de 200 instruÃ§Ãµes)
- **Menos de 10 mÃ©todos pÃºblicos** por classe
- **Menos de 10 propriedades** por classe
- **Declarar interfaces** para definir contratos
- **Usar readonly** para dados que nÃ£o mudam
- **Preferir imutabilidade** para dados

### ğŸ“‹ Exemplo de Classe Bem Estruturada
```typescript
/**
 * ServiÃ§o responsÃ¡vel pela gestÃ£o de usuÃ¡rios
 */
@Injectable()
export class UserService {
  private readonly maxRetries = 3;
  private readonly defaultPageSize = 20;
  
  constructor(
    private readonly userRepository: UserRepository,
    private readonly userValidator: UserValidator,
    private readonly userFactory: UserFactory,
  ) {}
  
  /**
   * Cria um novo usuÃ¡rio
   * @param userData - Dados do usuÃ¡rio
   * @returns Promise com o usuÃ¡rio criado
   */
  async criarNovoUser(userData: CreateUserDto): Promise<User> {
    if (!this.userValidator.validarDadosDoUser(userData)) {
      throw new ValidationError('Dados de usuÃ¡rio invÃ¡lidos');
    }
    
    const user = this.userFactory.criarNovo(userData);
    return this.userRepository.salvar(user);
  }
}
```

## ğŸ—ï¸ PadrÃµes Arquiteturais EspecÃ­ficos

### ğŸ¯ PadrÃ£o CRUD GenÃ©rico
Todos os mÃ³dulos devem seguir padrÃµes consistentes para operaÃ§Ãµes CRUD:

```typescript
// MÃ©todos CRUD obrigatÃ³rios
async buscarTodos(page = 1, limit = 20) { /* Lista com paginaÃ§Ã£o */ }
async buscarPorId(id: string) { /* Busca especÃ­fica */ }
async criar(dto: CreateDto) { /* CriaÃ§Ã£o */ }
async atualizar(id: string, dto: UpdateDto) { /* AtualizaÃ§Ã£o */ }
async desativar(id: string) { /* Soft delete */ }
async reativar(id: string) { /* Restaurar */ }
async deletar(id: string) { /* Hard delete */ }

// MÃ©todos especÃ­ficos por necessidade
async buscarPorEmail(email: string) { /* Campo especÃ­fico */ }
async buscarPorCompany(companyId: string) { /* Relacionamento */ }
```

### ğŸ—ï¸ Arquitetura Modular (PadrÃ£o do Projeto)
Cada mÃ³dulo deve ser estruturado seguindo o padrÃ£o estabelecido:

```typescript
// Repository - Acesso a dados
@Injectable()
export class UserRepository {
  async buscarMuitos(where: Prisma.UserWhereInput, options?: { skip?: number; take?: number }) { }
  async buscarPrimeiro(where: Prisma.UserWhereInput) { }
  async criarNovo(data: Prisma.UserCreateInput) { }
}

// Validator - ValidaÃ§Ãµes centralizadas
@Injectable()
export class UserValidator {
  async validarSeEmailEhUnico(email: string, excludeUserId?: string) { }
  async validarSeUserExiste(id: string) { }
  async validarSeCompanyExiste(companyId: string) { }
}

// Factory - CriaÃ§Ã£o de objetos
@Injectable()
export class UserFactory {
  criarNovoAdmin(dto: CreateAdminDto): Prisma.UserCreateInput { }
  criarNovoGuard(dto: CreateGuardDto): Prisma.UserCreateInput { }
}

// Service - OrquestraÃ§Ã£o
@Injectable()
export class UserService {
  constructor(
    private readonly userRepository: UserRepository,
    private readonly userValidator: UserValidator,
    private readonly userFactory: UserFactory,
  ) {}
}
```

### ğŸ“Š Sistema de Roles HierÃ¡rquico
O projeto possui 7 tipos de usuÃ¡rios com hierarquia especÃ­fica:

```typescript
enum Roles {
  SYSTEM_ADMIN,    // MÃ¡ximo acesso
  ADMIN,           // Acesso Ã  empresa
  SUPERVISOR,      // SupervisÃ£o de guardas
  HR,              // Recursos humanos
  GUARD,           // Vigilantes de seguranÃ§a
  POST_SUPERVISOR, // Supervisor de posto
  POST_RESIDENT    // Morador/residente
}

// AssociaÃ§Ã£o com postos
// POST_SUPERVISOR e POST_RESIDENT: associados a exatamente 1 posto
// Outros roles: nÃ£o associados a postos
```

### ğŸ¢ Multi-Tenancy
Sistema multi-tenant com isolamento por empresa:

```typescript
// Sempre filtrar por companyId quando aplicÃ¡vel
const whereClause = {
  companyId: this.tenantService.getCurrentTenant().id,
  ...otherFilters
};

// Validar pertencimento ao tenant
await this.validarSeCompanyExiste(companyId);
```

## ğŸ›¡ï¸ SeguranÃ§a e ValidaÃ§Ã£o

### ğŸ” AutenticaÃ§Ã£o e AutorizaÃ§Ã£o
- Usar `@UseGuards(AuthGuard)` para proteger rotas
- Implementar `@RequiredRoles()` para controle de acesso
- Sempre validar permissÃµes por tipo de usuÃ¡rio
- Usar sistema CASL para permissÃµes granulares

### âœ… ValidaÃ§Ã£o de Dados
- Usar **class-validator** em DTOs
- Implementar validaÃ§Ãµes customizadas quando necessÃ¡rio
- Sempre validar dados de entrada
- **Evitar validaÃ§Ãµes em funÃ§Ãµes** - usar classes com validaÃ§Ã£o interna

### ğŸ”’ ValidaÃ§Ãµes Customizadas EspecÃ­ficas
```typescript
// ValidaÃ§Ãµes especÃ­ficas do projeto
@IsStrongPassword()     // Senha forte obrigatÃ³ria
@IsUniqueEmail()       // Email Ãºnico por empresa
@IsUniqueCPF()         // CPF Ãºnico por empresa
@IsCPF()               // CPF vÃ¡lido
@IsPhoneNumberBR()     // Telefone brasileiro vÃ¡lido
```

## ğŸš¦ Tratamento de ExceÃ§Ãµes

### ğŸ”„ Sistema de Filtros HierÃ¡rquico
```typescript
// Filtros especÃ­ficos por tipo de erro
@Catch(TokenExpiredError)
export class TokenExpiredErrorFilter { }

@Catch(ValidationError)
export class ValidationErrorFilter { }

@Catch(NotFoundError)
export class NotFoundErrorFilter { }

// Filtro base para funcionalidades comuns
export abstract class BaseExceptionFilter {
  protected sendErrorResponse(
    exception: any,
    host: ArgumentsHost,
    status: HttpStatus,
    errorCode: string,
    message: string,
  ) {
    // Resposta padronizada
  }
}
```

### ğŸ” DetecÃ§Ã£o AutomÃ¡tica de Erros
```typescript
// Sistema detecta automaticamente erros de token
protected detectTokenError(exception: any): { isTokenError: boolean; errorCode: string } {
  if (exception instanceof UnauthorizedException) {
    const message = exception.message;
    
    if (message === AUTH_MESSAGES.ERROR.TOKEN_EXPIRED) {
      return { isTokenError: true, errorCode: 'TOKEN_EXPIRED' };
    }
    
    if (message === AUTH_MESSAGES.ERROR.TOKEN_INVALID) {
      return { isTokenError: true, errorCode: 'TOKEN_INVALID' };
    }
  }
  
  return { isTokenError: false, errorCode: 'UNKNOWN_ERROR' };
}
```

### ğŸ“‹ Exemplo de Tratamento de ExceÃ§Ãµes
```typescript
@Injectable()
export class UserService {
  async criarNovoUser(userData: CreateUserDto): Promise<User> {
    try {
      // Early return para validaÃ§Ãµes
      if (!userData.email) {
        throw new ValidationError('Email Ã© obrigatÃ³rio');
      }
      
      const user = await this.userRepository.criarNovo(userData);
      return user;
    } catch (error) {
      if (error instanceof ValidationError) {
        // Adicionar contexto especÃ­fico
        throw new UserCreationError(`Falha ao criar usuÃ¡rio: ${error.message}`);
      }
      
      // Deixar outros erros para o handler global
      throw error;
    }
  }
}
```

## ğŸ“¦ Estrutura de DTOs e Modelos

### ğŸ“¥ Input DTOs
```typescript
export class CreateUserDto {
  @IsString()
  @IsNotEmpty()
  readonly name: string;

  @IsEmail()
  @IsUniqueEmail()
  readonly email: string;

  @IsEnum(Roles)
  readonly role: Roles;

  @IsStrongPassword()
  readonly password: string;
}
```

### ğŸ“¤ Output DTOs
```typescript
export class UserResponseDto {
  readonly id: string;
  readonly name: string;
  readonly email: string;
  readonly role: Roles;
  readonly createdAt: Date;
}
```

### ğŸ”— Tipos de Dados
- **NÃ£o abusar de tipos primitivos**
- **Encapsular dados em tipos compostos**
- **Usar readonly** para dados imutÃ¡veis
- **Usar as const** para literais que nÃ£o mudam

## ğŸ“¨ Sistema de Mensagens Centralizadas

### ğŸ¯ Uso das Constantes
```typescript
// Sempre usar constantes centralizadas
import { VALIDATION_MESSAGES, ERROR_MESSAGES, SUCCESS_MESSAGES } from '../shared/common/messages';

// Em validaÃ§Ãµes
@IsString({ message: VALIDATION_MESSAGES.REQUIRED.NAME })
name: string;

// Em exceÃ§Ãµes
throw new NotFoundError(ERROR_MESSAGES.RESOURCE.NOT_FOUND);

// Em respostas
return { message: SUCCESS_MESSAGES.CRUD.CREATED };
```

### ğŸ’¬ InterpolaÃ§Ã£o de VariÃ¡veis
```typescript
// Usando o MessagesService
const message = this.messagesService.createCustomMessage(
  'UsuÃ¡rio {name} criado na empresa {companyName}',
  { name: 'JoÃ£o Silva', companyName: 'Empresa ABC' }
);
```

## ğŸ® Controllers e Endpoints

### ğŸŒ PadrÃµes de Endpoints
- **Endpoints SEMPRE em portuguÃªs**: `obterTodosOsUsers()`, `criarNovoAdmin()`, `updateDadosDoUser()`
- **Seguir padrÃµes REST** com verbos HTTP corretos
- **Usar DTOs** para validaÃ§Ã£o de entrada
- **Documentar com Swagger** todos os endpoints

### ğŸ“‹ Exemplo de Controller
```typescript
@Controller('users')
@ApiTags('UsuÃ¡rios')
export class UsersController {
  constructor(private readonly userService: UserService) {}

  @Get()
  @ApiOperation({ summary: 'Obter todos os usuÃ¡rios' })
  async obterTodosOsUsers(
    @Query('page') page: string = '1',
    @Query('limit') limit: string = '20'
  ): Promise<UserResponseDto[]> {
    return this.userService.buscarTodosOsUsers(+page, +limit);
  }

  @Get(':id')
  @ApiOperation({ summary: 'Obter usuÃ¡rio por ID' })
  async obterUserPorId(@Param('id') id: string): Promise<UserResponseDto> {
    return this.userService.buscarUserPorId(id);
  }

  @Post('admin')
  @ApiOperation({ summary: 'Criar novo admin' })
  async criarNovoAdmin(@Body() dto: CreateAdminDto): Promise<UserResponseDto> {
    return this.userService.criarNovoAdmin(dto);
  }

  @Patch(':id')
  @ApiOperation({ summary: 'Atualizar dados do usuÃ¡rio' })
  async updateDadosDoUser(
    @Param('id') id: string,
    @Body() dto: UpdateUserDto
  ): Promise<UserResponseDto> {
    return this.userService.updateUser(id, dto);
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Remover usuÃ¡rio do sistema' })
  async removerUserDoSistema(@Param('id') id: string): Promise<void> {
    return this.userService.removerUser(id);
  }
}
```

## ğŸ“Š Banco de Dados

### ğŸ—ƒï¸ Prisma ORM
- Usar **Prisma** para acesso ao banco
- Implementar **soft delete** quando necessÃ¡rio
- Adicionar **auditoria** (createdAt, updatedAt, createdBy)
- **Entidades com Prisma** para persistÃªncia de dados

### ğŸ”— Relacionamentos
```typescript
// Sempre definir relacionamentos no schema
model User {
  id        String   @id @default(cuid())
  companyId String
  company   Company  @relation(fields: [companyId], references: [id])
  posts     Post[]   // Relacionamento com postos
  
  // Campos de auditoria obrigatÃ³rios
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  deletedAt DateTime?
  createdBy String?
  updatedBy String?
}
```

## ğŸ§ª Testes

### âœ… PrincÃ­pios de Testes
- **Usar Jest** como framework padrÃ£o
- **Seguir convenÃ§Ã£o Arrange-Act-Assert**
- **Nomear variÃ¡veis de teste claramente** (inputX, mockX, actualX, expectedX)
- **Escrever testes unitÃ¡rios** para cada funÃ§Ã£o pÃºblica
- **Usar test doubles** para simular dependÃªncias
- **Escrever testes de aceitaÃ§Ã£o** para cada mÃ³dulo

### ğŸ“‹ Estrutura de Testes
```typescript
describe('UserService', () => {
  let userService: UserService;
  let mockUserRepository: jest.Mocked<UserRepository>;
  
  beforeEach(() => {
    // Arrange
    mockUserRepository = {
      buscarPorId: jest.fn(),
      criarNovo: jest.fn(),
    } as any;
    
    userService = new UserService(mockUserRepository);
  });
  
  describe('criarNovoUser', () => {
    it('should create user successfully', async () => {
      // Arrange
      const inputUserData = { name: 'Test User', email: 'test@example.com' };
      const expectedUser = { id: '1', ...inputUserData };
      mockUserRepository.criarNovo.mockResolvedValue(expectedUser);
      
      // Act
      const actualUser = await userService.criarNovoUser(inputUserData);
      
      // Assert
      expect(actualUser).toEqual(expectedUser);
      expect(mockUserRepository.criarNovo).toHaveBeenCalledWith(inputUserData);
    });
  });
});
```

### ğŸ” Tipos de Testes
- **Testes unitÃ¡rios** para cada service e controller
- **Testes de integraÃ§Ã£o** para endpoints completos
- **Testes end-to-end** para cada mÃ³dulo de API
- **Smoke tests** em controllers (`admin/test` method)

## ğŸ“ DocumentaÃ§Ã£o

### ğŸ“š Swagger
- Documentar **todos os endpoints**
- Usar **@ApiTags()** para agrupamento
- Implementar **@ApiResponse()** para responses

### ğŸ“– JSDoc
```typescript
/**
 * ServiÃ§o responsÃ¡vel pela gestÃ£o de usuÃ¡rios
 */
@Injectable()
export class UserService {
  /**
   * Cria um novo usuÃ¡rio no sistema
   * @param userData - Dados do usuÃ¡rio a ser criado
   * @param companyId - ID da empresa
   * @returns Promise com o usuÃ¡rio criado
   * @throws ValidationError quando dados sÃ£o invÃ¡lidos
   */
  async criarNovoUser(userData: CreateUserDto, companyId: string): Promise<User> {
    // implementaÃ§Ã£o
  }
}
```

## ğŸš€ Performance

### âš¡ OtimizaÃ§Ãµes
- Usar **paginaÃ§Ã£o** em listas
- Implementar **cache** quando apropriado
- Otimizar **queries** do banco
- **Evitar N+1 queries**

### ğŸ“ˆ Monitoramento
- Usar **Winston** para logging
- Implementar **mÃ©tricas** com Prometheus
- Monitorar **performance** de endpoints

## ğŸ”§ ConfiguraÃ§Ã£o

### ğŸŒ VariÃ¡veis de Ambiente
- Usar **@nestjs/config** para configuraÃ§Ã£o
- Validar **variÃ¡veis obrigatÃ³rias**
- Separar configuraÃ§Ãµes por **ambiente**
- **UPPERCASE** para todas as variÃ¡veis

### ğŸ³ Docker
- Usar **multi-stage builds**
- Otimizar **imagens** para produÃ§Ã£o
- Implementar **health checks**

## âŒ Anti-Patterns (Evitar)

### ğŸš« Nomenclatura Incorreta
```typescript
// âŒ MÃ©todos em inglÃªs
async findUserById(id: string) { }
async createUser(dto: CreateUserDto) { }
async updateUser(id: string, dto: UpdateUserDto) { }

// âŒ Entidades em portuguÃªs
class Usuario { }
class Empresa { }
class Posto { }

// âŒ Propriedades em portuguÃªs  
interface User {
  identificador: string;
  nome: string;
  email: string;
}

// âŒ Endpoints em inglÃªs
@Get() findAllUsers() { }
@Post() createUser() { }
@Put(':id') updateUser() { }
```

### ğŸš« PadrÃµes Inconsistentes
```typescript
// âŒ Mistura de padrÃµes
async getUser(id: string) { }           // Deveria ser buscarUserPorId
async validateUser(id: string) { }      // Deveria ser validarSeUserExiste
async saveUser(dto: CreateUserDto) { }  // Deveria ser criarNovoUser
```

### ğŸš« Arquitetura Incorreta
```typescript
// âŒ LÃ³gica de negÃ³cio no controller
@Controller('users')
export class UsersController {
  @Post()
  async criarUser(@Body() dto: CreateUserDto) {
    // âŒ ValidaÃ§Ã£o no controller
    if (!dto.email) {
      throw new BadRequestException('Email Ã© obrigatÃ³rio');
    }
    
    // âŒ Acesso direto ao banco
    const user = await this.prisma.user.create({ data: dto });
    return user;
  }
}

// âŒ ValidaÃ§Ã£o misturada com lÃ³gica de negÃ³cio
@Injectable()
export class UserService {
  async criarUser(dto: CreateUserDto) {
    // âŒ ValidaÃ§Ã£o, criaÃ§Ã£o e persistÃªncia no mesmo lugar
    if (!dto.email) throw new Error('Email obrigatÃ³rio');
    const hashedPassword = await bcrypt.hash(dto.password, 10);
    return this.prisma.user.create({ data: { ...dto, password: hashedPassword } });
  }
}
```

## ğŸ“‹ Checklist de Desenvolvimento

### âœ… Antes de Commitar
- [ ] CÃ³digo segue **convenÃ§Ãµes** estabelecidas
- [ ] **Nomenclatura** segue padrÃµes do projeto (mÃ©todos em portuguÃªs, entidades em inglÃªs)
- [ ] **Tipos TypeScript** declarados corretamente
- [ ] **FunÃ§Ãµes curtas** com propÃ³sito Ãºnico (mÃ¡ximo 20 instruÃ§Ãµes)
- [ ] **JSDoc** em classes e mÃ©todos pÃºblicos
- [ ] **ValidaÃ§Ãµes** implementadas usando validators centralizados
- [ ] **Tratamento de erros** usando sistema de filtros
- [ ] **Mensagens** usando constantes centralizadas
- [ ] **Testes** implementados e passando
- [ ] **DocumentaÃ§Ã£o** atualizada
- [ ] **SeguranÃ§a** validada
- [ ] **Performance** verificada
- [ ] **PadrÃ£o CRUD** seguido
- [ ] **Estrutura modular** respeitada

### ğŸš¦ Code Review
- Verificar **arquitetura** seguida (Repository, Validator, Factory, Service)
- Validar **nomenclatura** correta (portuguÃªs para mÃ©todos, inglÃªs para entidades)
- Confirmar **tipos TypeScript** adequados
- Verificar **funÃ§Ãµes** com responsabilidade Ãºnica
- Validar **seguranÃ§a** implementada
- Confirmar **performance** adequada
- Checar **tratamento de erros** usando filtros especÃ­ficos
- Validar **testes** adequados
- Verificar **padrÃµes especÃ­ficos** do projeto
- Confirmar **mensagens centralizadas**
- Validar **multi-tenancy** se aplicÃ¡vel
- Checar **validaÃ§Ãµes customizadas**

### ğŸ§ª Qualidade de CÃ³digo
- **FunÃ§Ãµes**: MÃ¡ximo 20 instruÃ§Ãµes
- **Classes**: MÃ¡ximo 200 instruÃ§Ãµes, 10 mÃ©todos pÃºblicos
- **Cobertura de testes**: MÃ­nimo 80%
- **Sem uso de `any`**: Tipos explÃ­citos
- **DocumentaÃ§Ã£o**: JSDoc em APIs pÃºblicas
- **Nomenclatura**: Seguir padrÃµes estabelecidos no NAMING_CONVENTIONS.md
- **Arquitetura**: Seguir padrÃ£o modular estabelecido
- **Mensagens**: Usar constantes centralizadas
- **ValidaÃ§Ãµes**: Usar validators customizados
- **Erros**: Usar sistema de filtros especÃ­ficos

---

## ğŸ“ Importante

**Sempre consultar estas regras** antes de implementar novas funcionalidades. Em caso de dÃºvida, seguir os **padrÃµes jÃ¡ estabelecidos** no projeto.

**ğŸ“‹ ReferÃªncias obrigatÃ³rias**:
- `docs/NAMING_CONVENTIONS.md` - PadrÃµes especÃ­ficos de nomenclatura
- `docs/CODING_STANDARDS.md` - PadrÃµes gerais de codificaÃ§Ã£o
- `docs/padroes/crud-generic-pattern.md` - PadrÃ£o CRUD genÃ©rico
- `src/shared/common/messages/README.md` - Sistema de mensagens
- `src/shared/common/filters/README.md` - Sistema de filtros
- `src/shared/auth/README.md` - Sistema de autenticaÃ§Ã£o
- `src/shared/casl/README.md` - Sistema de autorizaÃ§Ã£o
- `src/modules/users/services/README.md` - Arquitetura modular

**Foco atual**: Implementar funcionalidades core (Rondas, OcorrÃªncias, Turnos) seguindo estas diretrizes e os padrÃµes de nomenclatura estabelecidos.